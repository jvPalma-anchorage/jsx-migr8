/**
 * Git integration for backup system
 * Captures git state and provides git-aware backup operations
 */
import { execSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";

import { GitState, GitIntegrationError } from "./types";

/**
 * Handles Git integration for the backup system
 */
export class GitIntegration {
  constructor(private enabled: boolean = true) {}

  /**
   * Capture current git state
   */
  async captureGitState(projectRoot: string): Promise<GitState | null> {
    if (!this.enabled) {
      return null;
    }

    try {
      // Check if we're in a git repository
      if (!(await this.isGitRepository(projectRoot))) {
        return null;
      }

      const gitState: GitState = {
        branch: await this.getCurrentBranch(projectRoot),
        commitHash: await this.getLatestCommitHash(projectRoot),
        shortHash: await this.getShortCommitHash(projectRoot),
        commitMessage: await this.getLatestCommitMessage(projectRoot),
        author: await this.getLatestCommitAuthor(projectRoot),
        workingDir: await this.getWorkingDirectoryStatus(projectRoot),
        remote: await this.getRemoteInfo(projectRoot),
      };

      return gitState;
    } catch (error) {
      console.warn("Warning: Could not capture git state:", error);
      return null;
    }
  }

  /**
   * Create a git commit for backup operation
   */
  async createBackupCommit(
    projectRoot: string,
    backupId: string,
    message: string,
  ): Promise<string | null> {
    if (!this.enabled) {
      return null;
    }

    try {
      // Check if there are changes to commit
      const hasChanges = await this.hasUncommittedChanges(projectRoot);
      if (!hasChanges) {
        return null;
      }

      // Stage all changes
      await this.executeGitCommand("add .", projectRoot);

      // Create commit
      const commitMessage = `${message}\n\nBackup ID: ${backupId}\nGenerated by jsx-migr8 backup system`;
      await this.executeGitCommand(`commit -m "${commitMessage}"`, projectRoot);

      // Return new commit hash
      return await this.getLatestCommitHash(projectRoot);
    } catch (error) {
      throw new GitIntegrationError(
        "Failed to create backup commit",
        "git commit",
        error instanceof Error ? error.message : String(error),
      );
    }
  }

  /**
   * Create a git tag for backup
   */
  async createBackupTag(
    projectRoot: string,
    backupId: string,
    message: string,
  ): Promise<void> {
    if (!this.enabled) {
      return;
    }

    try {
      const tagName = `jsx-migr8-backup-${backupId}`;
      const tagMessage = `Backup created: ${message}`;

      await this.executeGitCommand(
        `tag -a "${tagName}" -m "${tagMessage}"`,
        projectRoot,
      );
    } catch (error) {
      throw new GitIntegrationError(
        "Failed to create backup tag",
        "git tag",
        error instanceof Error ? error.message : String(error),
      );
    }
  }

  /**
   * Check if current state matches a backup's git state
   */
  async verifyGitState(
    projectRoot: string,
    expectedState: GitState,
  ): Promise<{
    matches: boolean;
    differences: string[];
  }> {
    if (!this.enabled) {
      return { matches: true, differences: [] };
    }

    try {
      const currentState = await this.captureGitState(projectRoot);

      if (!currentState) {
        return {
          matches: false,
          differences: ["Current directory is not a git repository"],
        };
      }

      const differences: string[] = [];

      if (currentState.branch !== expectedState.branch) {
        differences.push(
          `Branch changed: ${expectedState.branch} → ${currentState.branch}`,
        );
      }

      if (currentState.commitHash !== expectedState.commitHash) {
        differences.push(
          `Commit changed: ${expectedState.shortHash} → ${currentState.shortHash}`,
        );
      }

      if (
        currentState.workingDir.hasChanges !==
        expectedState.workingDir.hasChanges
      ) {
        differences.push(
          `Working directory status changed: ${expectedState.workingDir.hasChanges ? "had changes" : "was clean"} → ${currentState.workingDir.hasChanges ? "has changes" : "is clean"}`,
        );
      }

      return {
        matches: differences.length === 0,
        differences,
      };
    } catch (error) {
      return {
        matches: false,
        differences: [
          `Error verifying git state: ${error instanceof Error ? error.message : String(error)}`,
        ],
      };
    }
  }

  /**
   * Get list of files changed since backup
   */
  async getChangedFilesSinceBackup(
    projectRoot: string,
    backupCommitHash: string,
  ): Promise<string[]> {
    if (!this.enabled) {
      return [];
    }

    try {
      const output = await this.executeGitCommand(
        `diff --name-only ${backupCommitHash}..HEAD`,
        projectRoot,
      );

      return output
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => line.length > 0)
        .map((relativePath) => path.resolve(projectRoot, relativePath));
    } catch (error) {
      throw new GitIntegrationError(
        "Failed to get changed files",
        "git diff",
        error instanceof Error ? error.message : String(error),
      );
    }
  }

  /**
   * Reset to backup state
   */
  async resetToBackupState(
    projectRoot: string,
    commitHash: string,
    force: boolean = false,
  ): Promise<void> {
    if (!this.enabled) {
      throw new GitIntegrationError(
        "Git integration is disabled",
        "git reset",
        "",
      );
    }

    try {
      const resetCommand = force
        ? `reset --hard ${commitHash}`
        : `reset --soft ${commitHash}`;
      await this.executeGitCommand(resetCommand, projectRoot);
    } catch (error) {
      throw new GitIntegrationError(
        "Failed to reset to backup state",
        "git reset",
        error instanceof Error ? error.message : String(error),
      );
    }
  }

  // ========================================================================
  // PRIVATE HELPER METHODS
  // ========================================================================

  private async isGitRepository(projectRoot: string): Promise<boolean> {
    try {
      const gitDir = path.join(projectRoot, ".git");
      const stats = await fs.promises.stat(gitDir);
      return stats.isDirectory();
    } catch {
      return false;
    }
  }

  private async getCurrentBranch(projectRoot: string): Promise<string> {
    try {
      return await this.executeGitCommand(
        "rev-parse --abbrev-ref HEAD",
        projectRoot,
      );
    } catch {
      return "unknown";
    }
  }

  private async getLatestCommitHash(projectRoot: string): Promise<string> {
    try {
      return await this.executeGitCommand("rev-parse HEAD", projectRoot);
    } catch {
      return "unknown";
    }
  }

  private async getShortCommitHash(projectRoot: string): Promise<string> {
    try {
      return await this.executeGitCommand(
        "rev-parse --short HEAD",
        projectRoot,
      );
    } catch {
      return "unknown";
    }
  }

  private async getLatestCommitMessage(projectRoot: string): Promise<string> {
    try {
      return await this.executeGitCommand("log -1 --pretty=%B", projectRoot);
    } catch {
      return "unknown";
    }
  }

  private async getLatestCommitAuthor(
    projectRoot: string,
  ): Promise<{ name: string; email: string }> {
    try {
      const name = await this.executeGitCommand(
        "log -1 --pretty=%an",
        projectRoot,
      );
      const email = await this.executeGitCommand(
        "log -1 --pretty=%ae",
        projectRoot,
      );
      return { name, email };
    } catch {
      return { name: "unknown", email: "unknown" };
    }
  }

  private async getWorkingDirectoryStatus(
    projectRoot: string,
  ): Promise<GitState["workingDir"]> {
    try {
      const statusOutput = await this.executeGitCommand(
        "status --porcelain",
        projectRoot,
      );
      const lines = statusOutput.split("\n").filter((line) => line.trim());

      const stagedFiles = lines.filter(
        (line) => line[0] !== " " && line[0] !== "?",
      ).length;
      const unstagedFiles = lines.filter(
        (line) => line[1] !== " " && line[1] !== "?",
      ).length;
      const untrackedFiles = lines.filter((line) =>
        line.startsWith("??"),
      ).length;

      return {
        hasChanges: lines.length > 0,
        stagedFiles,
        unstagedFiles,
        untrackedFiles,
      };
    } catch {
      return {
        hasChanges: false,
        stagedFiles: 0,
        unstagedFiles: 0,
        untrackedFiles: 0,
      };
    }
  }

  private async getRemoteInfo(
    projectRoot: string,
  ): Promise<GitState["remote"]> {
    try {
      const remoteName = await this.executeGitCommand("remote", projectRoot);
      if (!remoteName.trim()) {
        return undefined;
      }

      const firstRemote = remoteName.split("\n")[0].trim();
      const remoteUrl = await this.executeGitCommand(
        `remote get-url ${firstRemote}`,
        projectRoot,
      );

      // Get ahead/behind status
      let status: "up-to-date" | "ahead" | "behind" | "diverged" | "no-remote" =
        "no-remote";
      let aheadBy: number | undefined;
      let behindBy: number | undefined;

      try {
        const statusOutput = await this.executeGitCommand(
          `rev-list --count --left-right @{upstream}...HEAD`,
          projectRoot,
        );

        const [behind, ahead] = statusOutput.split("\t").map(Number);

        if (ahead === 0 && behind === 0) {
          status = "up-to-date";
        } else if (ahead > 0 && behind === 0) {
          status = "ahead";
          aheadBy = ahead;
        } else if (ahead === 0 && behind > 0) {
          status = "behind";
          behindBy = behind;
        } else {
          status = "diverged";
          aheadBy = ahead;
          behindBy = behind;
        }
      } catch {
        // Couldn't determine status - might not have upstream
        status = "no-remote";
      }

      return {
        name: firstRemote,
        url: remoteUrl,
        status,
        aheadBy,
        behindBy,
      };
    } catch {
      return undefined;
    }
  }

  private async hasUncommittedChanges(projectRoot: string): Promise<boolean> {
    try {
      const status = await this.executeGitCommand(
        "status --porcelain",
        projectRoot,
      );
      return status.trim().length > 0;
    } catch {
      return false;
    }
  }

  private async executeGitCommand(
    command: string,
    projectRoot: string,
  ): Promise<string> {
    try {
      const fullCommand = `git ${command}`;
      const output = execSync(fullCommand, {
        cwd: projectRoot,
        encoding: "utf8",
        stdio: ["ignore", "pipe", "pipe"],
      });

      return output.trim();
    } catch (error) {
      throw new GitIntegrationError(
        `Git command failed: ${command}`,
        command,
        error instanceof Error ? error.message : String(error),
      );
    }
  }
}
